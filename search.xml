<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BossCMSv1.3</title>
      <link href="/posts/4802fccc/"/>
      <url>/posts/4802fccc/</url>
      
        <content type="html"><![CDATA[        <h1 id="03-BossCMS-v1-3">          <a href="#03-BossCMS-v1-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#03-BossCMS-v1-3" class="headerlink" title="03-BossCMS v1.3"></a>03-BossCMS v1.3</h1>      <p>温州互引信息技术有限公司(以下简称互引信息、BossCMS、老板建站)是一家专注于软件开发、网</p><p>站建设、模板开发、平面设计及网站安全运维的企业，主要为中小型企业及政企单位还有需要使用CMS</p><p>建站系统的个人或开发团队提供新一代合规建站产品和服务。多年来我们始终围绕着互联网相关软件进</p><p>行有关业务的开展和产品研究，凭借持续的研发投入及不断的创新，已发展为建站系统领域中比较完整</p><p>的的CMS软件供应商。</p><p>至今，BossCMS产品经过了上百多次的调整，产品操作简单、功能完善、安全可靠、可视化编辑、</p><p>多语言、文件存储(支持本地或外部存储)、自定义页面URL、网站优化(SEO)设置、广告违禁词及城市分</p><p>站站群等功能，BossCMS是一款基于自主研发PHP框架+MySQL架构的网站管理系统，适应各类网站的</p><p>内容管理，同时备受终端用户和开发者好评的CMS建站系统。</p>        <h1 id="理清目录结构">          <a href="#理清目录结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#理清目录结构" class="headerlink" title="理清目录结构"></a>理清目录结构</h1>      <p>通过官方介绍，我们可以明白，BossCMS是自主研发的PHP框架。</p><p>看README文件，发现其采用了MVC设计模式，所以重点在于找C</p><p><img src="/posts/4802fccc/image-20231227191759-ef7r29p.png" alt="image"></p><p><img src="/posts/4802fccc/image-20231227192100-kr9fj1t.png" alt="image"></p><p>这说明前后台存在分离不同的功能点。所以需要区分前后台的路由访问方式。</p><p>‍</p>        <h1 id="路由分析">          <a href="#路由分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由分析" class="headerlink" title="路由分析"></a>路由分析</h1>      <p>通过访问入口文件，发现其定义了四个常量，这四个常量都是前台的路由，同时直接包含了enter.php文件</p><p><img src="/posts/4802fccc/image-20231227195718-llmdihn.png" alt="image"></p><p>进入enter.php文件，发现其包含了一个into.class.php的文件，同时进行了<code>into::load()</code>操作，很明显，这里是实例化类。</p><p><img src="/posts/4802fccc/image-20231227191831-f2jpcax.png" alt="image"></p><p>跟进load()函数。调用了load_class()函数，并且传入了参数进行了<code>defined()</code>判断，回到index.php中，发现BOSSCMS_TYPE定义的是web，这说明前台index.php中定义了一些路由的常量。</p><p><img src="/posts/4802fccc/image-20231227192434-ii16y4n.png" alt="image"></p><p><img src="/posts/4802fccc/image-20231227192546-2ei9ekm.png" alt="image"></p><p>跟进到<code>load_class()</code>方法，并且有注释说明是加载class类文件，同时注意其第一次if判断，它判断了<code>$type</code>这个变量，给出admin还是web，这说明<code>$type</code>变量是路由中用于区分后台还是前台web。</p><p><img src="/posts/4802fccc/image-20231227192223-6aeiza1.png" alt="image"></p><p>再分析下面包含的文件部分，可以发现被包含的文件，由传入的三个变量组成，<code>$type</code>、<code>$mold</code>、<code>$part</code>从而包含了一个类文件</p><p>从一开始的分析，我们知道<code>$type</code>是控制前后台的，而<code>$part</code>前面有<code>/</code>且后面直接拼接<code>.class.php</code>说明，这是决定文件名的，则由此判断<code>$mold</code>是控制目录的</p><p><img src="/posts/4802fccc/image-20231227193445-fmke89r.png" alt="image"></p><p>包含完文件后，我们看一下下面的函数，判断传入的<code>$func</code>变量，既然文件都包含了，这个多半是调用文件中的方法。利用call_user_func()，通过对象的方式回调类中的方法。</p><p>形如：</p><figure class="highlight php"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过对象的方式回调</span></span><br><span class="line"><span class="variable">$myobject</span> = <span class="keyword">new</span> <span class="title function_ invoke__">myclass</span>();</span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="keyword">array</span>(<span class="variable">$myobject</span>, <span class="string">&#x27;say_hello&#x27;</span>));</span><br></pre></td></tr></table></div></figure><p><img src="/posts/4802fccc/image-20231227193921-rvx35nr.png" alt="image"></p><p>‍</p>        <h2 id="路由分析结果">          <a href="#路由分析结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#路由分析结果" class="headerlink" title="路由分析结果"></a>路由分析结果</h2>      <p><code>$type</code>控制前后台，<code>$mold</code> 控制目录 <code>$part</code>控制类文件 <code>$func</code>控制类中调用方法</p><p>直接访问index.php,会自定义三种变量使其访问前台内容</p><p>如果访问&#x2F;admin&#x2F;index.php，也会自定义三种变量分别是：mold、part、func，只不过这三个变量可控，而<code>$type</code>变量直接由<code>IS_INSIDE</code>常量控制实现访问后台。</p><p>‍</p>        <h1 id="漏洞挖掘">          <a href="#漏洞挖掘" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h1>              <h2 id="文件上传">          <a href="#文件上传" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2>              <h3 id="漏洞分析">          <a href="#漏洞分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3>      <p>先找文件上传点，找到对应路由文件（这里有js前端写的验证，但是如果禁用js，整个上传点都废掉了）。就不从这里分析了。</p><p><img src="/posts/4802fccc/image-20231228165847-iyr945t.png" alt="image"></p><p>下面还有一个编辑器，里面存在图片上传（也是前端验证）和附件上传（后端验证），那么就追踪附件上传的运行逻辑</p><p><img src="/posts/4802fccc/image-20231228170153-szeu17b.png" alt="image"></p><p>追踪到controller.php文件，检测action函数，发现该文件中定义了mold，type，part，func等常量，这说明存在固定路由，访问对应文件<strong>extend&#x2F;ueditor&#x2F;php&#x2F;ueditor.class.php</strong>中的<code>init()</code>方法</p><p><img src="/posts/4802fccc/image-20231228170252-5nqhf5g.png" alt="image"></p><p>在init()方法中，找到了附件上传的函数，追踪对应代码</p><p><img src="/posts/4802fccc/image-20231228170506-50wb09c.png" alt="image"></p><p>追踪到对应函数，查看其执行逻辑，主要先找用于上传的函数，判断的地方可以先不看。</p><p>很明显，这里调用了一个上传的静态方法，先追踪其使用方式到<strong>system&#x2F;basic&#x2F;class&#x2F;upload.class.php</strong>文件中的<code>file()</code>函数</p><p><img src="/posts/4802fccc/image-20240103123719-eyqcyac.png" alt="image"></p><p>找到上传相关函数，这里调用的是<code>move_upload_file()</code>函数。根据该函数的使用方式，可以直接看上面的判断，进行溯源，看能否构成完整的逻辑调用链，从调用链中寻找绕过漏洞。</p><p><img src="/posts/4802fccc/image-20240103123909-t1l0a84.png" alt="image"></p><p><em>注：在后台安全设置中找到一个允许上传后缀的设置，通过抓包发现，该功能点可以控制对应config文件中的</em><code>*upload_extension*</code><em>字段</em></p><p><img src="/posts/4802fccc/image-20240103124715-3zrnp5f.png" alt="image"></p><p>继续看<strong>upload.class.php</strong>文件中的函数，通过<code>pathinfo()</code>函数获取后缀名，<code>$extension</code>变量是直接读取<strong>config</strong>文件中的，而这个允许上传后缀的<code>$extension</code>可以通过后台功能点设置，所以是可控的。</p><p>那么下面第一个判断<code>in_array($ext,$extension)</code>是可以控制的判断，再看第二个判断，这里需要<code>!$type</code>为true或者(<code>$type &amp;&amp; !$in</code>)为true，追踪上传时传入的函数参数传递，有传入type，所以<code>$type</code>不为null。这就要看第一个<code>if()</code>判断函数，其中涉及的<code>$type</code>变量的更改。</p><p><img src="/posts/4802fccc/image-20240103124517-ctauark.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240103125211-s8sd5a7.png" alt="image"></p><p>这里只需要<code>$type</code>为False或者<code>$type &amp;&amp; !$in</code>为True即可。</p><p>分析第一个<code>if()</code>判断函数，传入的是<code>code|zip|word|excel|powerpoint|audio|text|pdf</code>，利用<code>foreach()</code>函数遍历<strong>extension.json</strong>文件中的函数，通过对比可以知道其中<code>if(in_array($k,$tarr))</code>是True，无法控制的，那么只要<code>if(in_array($ext,$v))</code>能够true就能实现<code>$type=null</code>，而通过观察extension.json文件，发现只需要传入允许的后缀即可，所以可以传入php文件。至此<strong>upload.class.php</strong>文件分析结束</p><p><img src="/posts/4802fccc/image-20240103131238-1yld8em.png" alt="image"></p><p>回到<strong>ueditor.class.php</strong>文件</p><p><img src="/posts/4802fccc/image-20240103131440-72rb4pc.png" alt="image"></p><p>这里的判断都是可控的，而且没有进行过滤，所以不用太在意。</p><p>所以整体调用链：调用uploadfile()函数，判断是否有参数<code>upfile</code>传入，且将其值赋值给<code>$file</code>&#x3D;&gt; 判断文件大小 &#x3D;&gt;调用文件上传函数<code>upload::file</code>,需要进入第一个<code>if()</code>判断，有文件上传且没有错误(即上传成功) &#x3D;&gt;判断后缀，这里需要借助安全设置中的配置添加php文件上传。从而绕过判断。</p><p><img src="/posts/4802fccc/image-20240103131722-082e43v.png" alt="image"></p><p>‍</p>        <h3 id="利用方式">          <a href="#利用方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3>      <p>现在安全设置中添加允许上传的php后缀。<img src="/posts/4802fccc/image-20240103132054-dj089f8.png" alt="image"></p><p>寻找调用<code>uploadfile()</code>函数的功能点，根据调用的文件名ueditor.class.php可以猜测这里使用的ueditor编辑器。所以从编辑器中找文件上传，一般是附件上传<img src="/posts/4802fccc/image-20240103132236-i2hum7h.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240103133227-9spzu8v.png" alt="image"><img src="/posts/4802fccc/image-20240103133242-rkw7mtp.png" alt="image"><img src="/posts/4802fccc/image-20240103133256-bl5ilm4.png" alt="image"></p><p>‍</p><p>‍</p>        <h2 id="任意文件删除">          <a href="#任意文件删除" class="heading-link"><i class="fas fa-link"></i></a><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h2>              <h3 id="漏洞分析-1">          <a href="#漏洞分析-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3>      <p>同样在<strong>ueditor.class.php</strong>文件中，里面存在一个<code>delete()</code>函数</p><p><img src="/posts/4802fccc/image-20240103143614-uejfi0q.png" alt="image"></p><p>通过POST方法传入path参数，获取config文件中的<code>store_type</code>参数来判断是否进行下一步，这边动用了两个方法进行删除，一个是<code>dir::delete</code>和<code>oss::delete</code>。全局搜索**<code>store_type</code>**，发现这个是用于控制存储方式的参数，默认为0，即直接调用<code>dir::delete</code>方法</p><p><img src="/posts/4802fccc/image-20240103144145-w91t66s.png" alt="image"></p><p>在dir.class.php文件中，可以看到delete()方法中调用了unlink()函数，可以看到这里除了调用replace()方法外，就是直接判断是否为文件，从而执行<code>unlink()</code>函数</p><p><img src="/posts/4802fccc/image-20240103144258-pbyfch0.png" alt="image"></p><p>现在只需要追溯<code>replace()</code>方法的执行结果。</p><p>看注释是替换路径分割字符，通过分析其正则替换，只是对路径的一些字符进行替换，并没有设置什么过滤，所以可以初步判断存在任意文件删除，现在只需要根据路由构造payload，看能否成功。</p><p><img src="/posts/4802fccc/image-20240103144828-pxazrmo.png" alt="image"></p><p>‍</p>        <h3 id="漏洞利用">          <a href="#漏洞利用" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3>      <ol><li>判断是否利用post方法，提交path参数</li><li>提交的参数是否以upload开头</li><li>默认采用<code>dir::delete()</code>方法，先进行replace()函数，过滤掉多余的，例如<code>//</code>,然后就直接进行unlink()函数</li></ol><p>构造Payload如下，因为这里是ueditor文件中的，所以delete功能点一定也在这个编辑器中，所以构造payload时的路由需要根据这个编辑器中的调用方式来构造。</p><p><img src="/posts/4802fccc/image-20240103152204-lgho1yi.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240103152215-gwewa1l.png" alt="image"></p><p>‍</p>        <h2 id="目录遍历">          <a href="#目录遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2>              <h3 id="漏洞分析-2">          <a href="#漏洞分析-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3>      <p>浏览lists()函数，发现这里对于传入的<code>$path</code>参数，并没有进行过滤，而是直接传入到<code>read()</code>函数中进行读取。通过分析，发现这里调用了两种read(),其中<code>oss::read()</code>是远程读取，<code>dir::read()</code>是本地读取，所以优先看本地读取函数</p><p><img src="/posts/4802fccc/image-20240106152937-dxmb71e.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240106153040-fw4hn2u.png" alt="image"></p><p>看似是判断数组是否存在，实际上看<code>$val = $val[$v]</code> 有点变量覆盖的意思在其中，实现函数调用。</p><p>看dir::read()方法，里面调用了<code>opendir()</code>和<code>readdir()</code>函数，可以看到，对于传入的<code>$path</code>也是直接调用，并没有进行过滤等操作，最后通过return，返回读取到的文件名</p><p><img src="/posts/4802fccc/image-20240106153343-awsjed1.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240106153429-jzbolrg.png" alt="image"></p><p>回到<code>lists()</code>方法，发现这个函数并没有直接输出，而是通过<code>return</code>返回了遍历得到的数组名，所以无法直接通过路由构造出目录遍历漏洞。需要去找调用点。–&gt;查找方法。</p><p><img src="/posts/4802fccc/image-20240106153525-y2j4fj0.png" alt="image"></p><p>找到一处调用lists()方法的地方，发现最后还是return了一组<code>json::encode</code> 的数据，同时这里也没有对传入的数据进行过滤。但是这里也没有对数据进行输出，而且这里<code>listfile()</code>方法也没有传入参数，这表明存在一个地方调用该方法。&#x3D;&gt;全文查找。</p><p><img src="/posts/4802fccc/image-20240106154038-he3xba9.png" alt="image"></p><p>最后在init()函数中找到了调用方式，通过get得到的action，利用switch跳转到对应的分支，用<code>$result</code>接收函数，最后利用<code>echo</code>输出<code>callback()</code>函数回调的结果</p><p><img src="/posts/4802fccc/image-20240106155000-5s9ryx9.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240106155016-1wpeujq.png" alt="image"></p><p>此时只需要分析<code>config[&#39;fileManagerActionName&#39;]</code>是什么即可，追溯到config.json文件中，里面制定了action接收的是listfile时，调用listfile()方法。并且规定了默认列出的文件目录为<code>upload/</code></p><p><img src="/posts/4802fccc/image-20240106155508-vjoaueg.png" alt="image"></p>        <h3 id="小结">          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h3>      <p>整理一下整体实现逻辑链</p><ol><li>传入action参数，用于指定调用方法（这里调用的是<code>listfile()</code>）</li><li>调用<code>listfile()</code>方法时，直接调用<code>lists()</code>方法没有经过任何判断，默认传入<code>upload/</code>目录</li><li>在lists()方法中，有拼接的操作，通过审核<code>arrExist()</code>方法，发现其进行了简单的变量覆盖，通过传入<em><strong>folder</strong></em>，实现参数传递。</li><li>因为store_type值默认为0，所以会自动执行本地读取文件操作，即<code>dir::read()</code>,同时传入默认的<code>upload/</code>以及<em><strong>folder</strong></em>参数拼接而成的路径。</li><li>在<code>dir::read()</code>方法中，通过调用<code>opendir()</code>和<code>readdir()</code>两个函数，读取目录，同时返回读取到的内容。</li><li>最后再在init()方法中的echo输出。</li></ol>        <h3 id="漏洞利用-1">          <a href="#漏洞利用-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3>      <p>分析过程中，我们知道了这是附件上传可能会调用到的函数。只需要控制<strong>action</strong>和添加<strong>folder</strong>这个拼接参数，就可以实现绕过。找到功能点在在线附件中。</p><p><img src="/posts/4802fccc/image-20240106175432-js8p3am.png" alt="image"></p><p>通过前面的分析，我们知道只需要传入action和folder两个参数即可，删除其他参数吗，避免造成干扰</p><p><img src="/posts/4802fccc/image-20240106175553-dfft1d2.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240106175626-9i0vz92.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240106175714-2q7z16a.png" alt="image"></p><p>‍</p><p>‍</p>        <h2 id="任意文件下载">          <a href="#任意文件下载" class="heading-link"><i class="fas fa-link"></i></a><a href="#任意文件下载" class="headerlink" title="任意文件下载"></a>任意文件下载</h2>              <h3 id="漏洞分析-3">          <a href="#漏洞分析-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3>      <p>在后台找功能点，但凡含有下载的字样的，都可以试一试</p><p><img src="/posts/4802fccc/image-20240106182901-hgo1p72.png" alt="image"></p><p>找到对应的函数位置</p><p><img src="/posts/4802fccc/image-20240106182936-obau3vt.png" alt="image"></p><p>发现函数执行部分没有任何过滤，直接通过拼接的方式获取文件路径，然后调用readfile()函数，读取文件内容到输出缓存（这里没有接收，相当于直接下载），那么只需要直接修改接收的id值，就可以实现任意文件下载了</p><p>‍</p>        <h3 id="漏洞利用-2">          <a href="#漏洞利用-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h3>      <p><img src="/posts/4802fccc/image-20240106183205-7c1le2t.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240106183229-gjpm4cp.png" alt="image"></p><p>‍</p>        <h2 id="权限校验逻辑缺陷">          <a href="#权限校验逻辑缺陷" class="heading-link"><i class="fas fa-link"></i></a><a href="#权限校验逻辑缺陷" class="headerlink" title="权限校验逻辑缺陷"></a>权限校验逻辑缺陷</h2>              <h3 id="漏洞分析-4">          <a href="#漏洞分析-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞分析-4" class="headerlink" title="漏洞分析"></a>漏洞分析</h3>      <p>在<strong>ueditor.class.php</strong>文件中，定义的ueditor类继承了admin，这表示需要通过admin身份验证才能够执行的操作。</p><p><img src="/posts/4802fccc/image-20240107172021-nxvtvbk.png" alt="image"></p><p>其次继承的类，通过<code>into::basic_class()</code>方法加载对应的类，追溯<code>basic_class()</code>方法。</p><p>因为没有传入<code>$func</code>，所以会设置<code>$func=&#39;init&#39;</code>，同时最后会进行<code>load_class()</code>方法，追溯到<code>load_class()</code>方法，这里前面分析过，就是判断是否为后端来加载类中方法。因为传入的<code>$name=&#39;admin&#39;</code>所以会加载<code>admin.class.php</code>文件中的<code>$func</code>，也就是<code>init()</code>方法</p><p><img src="/posts/4802fccc/image-20240107172217-zsfvfv6.png" alt="image"></p><p>追溯到<strong>admin.class.php</strong>文件中的<code>init()</code>方法。</p><p>这里可以看到通过session来判断是否登录，如果判断为空，且没有设置<code>IS_LOGIN</code>就会实现跳转。但是并没有其他函数执行，例如<code>die()</code>函数，结束执行<code>init()</code>中的代码。这就意味着如果构造后台操作路由，还是会导致执行，只不过会触发跳转到登录界面。而不是<code>die()</code>直接结束加载类</p><p><img src="/posts/4802fccc/image-20240107174651-y0px1y8.png" alt="image"></p><p>‍</p>        <h3 id="漏洞实现">          <a href="#漏洞实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞实现" class="headerlink" title="漏洞实现"></a>漏洞实现</h3>      <p><img src="/posts/4802fccc/image-20240107185431-qhvolx6.png" alt="image"></p><p>‍</p><p><img src="/posts/4802fccc/image-20240107185449-fo4hfjq.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240107185503-2w3hhwd.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240107185509-txf6ubd.png" alt="image"></p><p><img src="/posts/4802fccc/image-20240107185513-v2tj6jv.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五指cms代码审计</title>
      <link href="/posts/e754e93d/"/>
      <url>/posts/e754e93d/</url>
      
        <content type="html"><![CDATA[        <h1 id="01-五指CMS">          <a href="#01-五指CMS" class="heading-link"><i class="fas fa-link"></i></a><a href="#01-五指CMS" class="headerlink" title="01-五指CMS"></a>01-五指CMS</h1>              <h1 id="01-看文档">          <a href="#01-看文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#01-看文档" class="headerlink" title="01-看文档"></a>01-看文档</h1>      <p><img src="/posts/e754e93d/image-20231220144430-xqf5j99.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231220144447-lwxjaht.png" alt="image">​</p><p>目的：了解基本架构，看主要目录</p><p>‍</p>        <h1 id="02-审计">          <a href="#02-审计" class="heading-link"><i class="fas fa-link"></i></a><a href="#02-审计" class="headerlink" title="02-审计"></a>02-审计</h1>              <h2 id="2-1-路由分析">          <a href="#2-1-路由分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-路由分析" class="headerlink" title="2.1-路由分析"></a>2.1-路由分析</h2>      <p>发现存在入口文件，那么直接从入口文件入手。（那些定义环境什么的基本没用，因为基本不存在可控参数），直接看定义函数<code>load_class()</code>​</p><p><img src="/posts/e754e93d/image-20231220144702-b8scm2d.png" alt="image">​</p><p>load_class()，加载类函数，根据注释以及大概浏览，发现没有可控参数的传入，直接进入入口加载的文件。根据传入参数application,可以定位到其加载了<strong>application.class.php</strong>文件</p><p><img src="/posts/e754e93d/image-20231220144852-z6kx6tv.png" alt="image">​</p><p><em><strong>application.class.php文件</strong></em>：</p><p><img src="/posts/e754e93d/image-20231220145033-3q9pv59.png" alt="image">​</p><p>该文件是路由文件，指明了M-模块名，F-文件名，V-方法名</p><p><img src="/posts/e754e93d/image-20231220145137-l1l6vgy.png" alt="image">​</p><p>看一下setconfig()函数，说是设置路由，通过大概浏览，发现是对定义的路由变量，进行赋值以及过滤，但不是源输入口，所以看下面其他函数</p><p><img src="/posts/e754e93d/image-20231220145408-y4r3j8w.png" alt="image">​</p><p>下面有一个run()函数，对应着入口文件index.php中调用的函数，是理清路由的重点。</p><p><img src="/posts/e754e93d/image-20231220145549-7hqnfs6.png" alt="image">​</p><p>一开始调用了load_file()函数且默认传入参数为空，定位到函数位置，分析作用：</p><p><img src="/posts/e754e93d/image-20231220145908-lx0ggr0.png" alt="image">​</p><p>第一个判断，可以基本猜测与管理员有关。通过判断参数_su，来控制admin目录的设置。</p><p><img src="/posts/e754e93d/image-20231220150715-j8azra6.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231220150807-j5hg6y5.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231220150916-wn8u6uq.png" alt="image">​</p><p>找到函数返回值：返回对应类文件。</p><p>可以分析出基本路由：入口文件index.php加载application.class.php文件中的类，执行其中的run()方法，方法中通过调用load_file()方法，浏览代码内容后，发现通过传入M、F、V来控制传入对应的文件，进行处理，即MVC中Controller部分。</p><p>Model路径：<code>wuzhicms/coreframe/app/$app(M) . $_admin_dir(默认/admin)/$filename(F).php</code>​</p><p>因为存在<code>_su</code>​参数，来控制访问管理员目录，所以可以得出管理页面访问：<code>index.php?_su=wuzhicms&amp;m=core&amp;f=index</code>​</p><p>‍</p>        <h2 id="开始审计代码">          <a href="#开始审计代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#开始审计代码" class="headerlink" title="开始审计代码"></a>开始审计代码</h2>              <h3 id="1-CSRF">          <a href="#1-CSRF" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-CSRF" class="headerlink" title="1-CSRF"></a>1-CSRF</h3>      <p><img src="/posts/e754e93d/image-20231223162218-ynj7av7.png" alt="image">​</p><p>找到对应路由方法，发现只对提交的参数进行判断，并未对身份进行验证，所以存在CSRF实现任意用户添加<img src="/posts/e754e93d/image-20231223162319-id7wh6o.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231223162334-6jcdsep.png" alt="image">​</p><p>依照这个思路，可以大胆猜测对方在其他存在身份验证的地方也可能没有进行身份验证。</p><p>‍</p><p>‍</p>        <h3 id="2-目录遍历">          <a href="#2-目录遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-目录遍历" class="headerlink" title="2-目录遍历"></a>2-目录遍历</h3>      <p>搜索敏感函数</p><p>全局搜索<code>glob(</code>​，查找是否存在glob()函数的调用。</p><p><img src="/posts/e754e93d/image-20231223190422-18qewgu.png" alt="image">​</p><p>上面代码就是调用了glob()函数，匹配目录，同时使用<code>template</code>​​进行模板渲染，即存在结果返回<strong>前段显示</strong>。</p><p>寻找是否参数可控，函数方法乍一看没有传参，实际上这里是类方法，调用了<code>$this-&gt;dir</code>​,而<code>$this-&gt;dir</code>​在__construct()函数中可控，并且进行了简单过滤</p><p><img src="/posts/e754e93d/image-20231223190727-4xor7p0.png" alt="image">​</p><p>怎么触发呢？考虑到是模板，那么访问指定页面传入参数，就会自动触发类中的构造函数。</p><p><img src="/posts/e754e93d/image-20231223191005-ypilrh2.png" alt="image">​</p><p>根据路由，构造Payload：<code>index.php?m=template&amp;_su=wuzhicms&amp;f=index&amp;v=listing&amp;dir=.....///.....///.....///.....///.....///.....///</code>​</p><p><img src="/posts/e754e93d/image-20231223191655-jbvdov2.png" alt="image">​</p><ol><li>全局搜索敏感危险函数</li><li>寻找存在变量可控的相关函数</li><li>追溯整个调用链，看是否能够结果回显</li></ol><p>‍</p>        <h3 id="3-任意文件删除">          <a href="#3-任意文件删除" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-任意文件删除" class="headerlink" title="3-任意文件删除"></a>3-任意文件删除</h3>      <p>全局搜索unlink()函数，该函数是PHP中自带的文件删除函数。以下面为例，找到一个自定义方法中调用了unlink()函数，并且未进行过滤操作</p><p><img src="/posts/e754e93d/image-20231223212053-nq196p8.png" alt="image">，此时的思路就是去找哪里调用了这个方法，以及参数是否可控</p><p>其一：path是从数据库中提取的，我们无法控制，所以不能造成任意文件删除</p><p><img src="/posts/e754e93d/image-20231223212208-jgsyy6t.png" alt="image">​</p><p>其二：这里的<code>$path</code>​是由<code>$url</code>​控制，而<code>$url</code>​是可控的传入参数，里面调用了remove_xss()函数，过滤xss代码，</p><p><img src="/posts/e754e93d/image-20231223212303-604dvbt.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231223212346-ctf40cd.png" alt="image">​</p><p><code>remove_xss()</code>​过滤代码中未对<code>. /</code>​进行过滤，这就意味着可以进行目录遍历，然后实现文件删除</p><p><img src="/posts/e754e93d/image-20231223212514-5dhr4sl.png" alt="image">​</p><p>分析路由：需要进入else中语句，所以不能传入<code>$id</code>​，直接传入<code>$url</code>​</p><p>Payload：<code>http://www.testwuzhi.com/index.php?m=attachment&amp;f=index&amp;v=del&amp;url=../1.txt&amp;_su=wuzhicms</code>​</p><p><img src="/posts/e754e93d/image-20231223212754-pc1g4v0.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231223212614-dka9euf.png" alt="image">​</p><p>当前目录：</p><p><img src="/posts/e754e93d/image-20231223213025-v17n3zd.png" alt="image">​</p><p>也可以通过对应文件找到其页面中的功能点，从而利用抓包修改</p><p><img src="/posts/e754e93d/image-20231223213447-olmvf9q.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231223213459-k9aaany.png" alt="image">​</p><p>‍</p>        <h3 id="4-sql注入">          <a href="#4-sql注入" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-sql注入" class="headerlink" title="4-sql注入"></a>4-sql注入</h3>              <h4 id="删除用户交互">          <a href="#删除用户交互" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除用户交互" class="headerlink" title="删除用户交互"></a>删除用户交互</h4>              <h5 id="删除会员组">          <a href="#删除会员组" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除会员组" class="headerlink" title="删除会员组"></a>删除会员组</h5>              <h6 id="分析执行链">          <a href="#分析执行链" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析执行链" class="headerlink" title="分析执行链"></a>分析执行链</h6>      <p>根据路由找到对应文件</p><p><img src="/posts/e754e93d/image-20231224135925-e279zpn.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231224140026-tcx2ub4.png" alt="image">​</p><p>找到数据库交互位置，且参数可控，开始追溯整个执行链。</p><p>通过<code>db-&gt;delete()</code>​追溯到<strong>db.class.php</strong>文件中的<code>delete()</code>​函数，接着通过<code>master_db-&gt;delete()</code>​追溯到<strong>mysqli.class.php</strong>文件中的<code>delete()</code>​函数。此时发现函数中的sql语句直接拼接，不存在预处理什么的。再追溯到本文件中定义的<code>query()</code>​函数的定义（因为不是直接使用mysql语句，所以只能是自定义的语句）</p><blockquote><p>关于执行过程中，例如<code>array2sql()</code>​函数，暂时不用去分析其作用，如果后面执行链无法输出结果，前面怎么分析都是浪费时间</p></blockquote><p><img src="/posts/e754e93d/image-20231224140157-2dqikr0.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231224140306-3dsflek.png" alt="image">​</p><p>分析query()执行函数，里面调用了halt()函数，追溯其作用发现halt()函数是输出结果，依据if判断，可以知道如果sql查询失败了会执行halt，也就是报错信息输出，利用了mysqli_error()可以用于报错注入。</p><p>也就是说只要调用了自定义的query()函数，就可能存在报错注入的风险。</p><p><img src="/posts/e754e93d/image-20231224140725-snz0cuh.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231224140904-kr6hj5f.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231224140917-bp5v9hm.png" alt="image">​</p><p>‍</p><p>分析可能存在报错漏洞，整理执行链：<strong>member&#x2F;admin&#x2F;group.php</strong>​<code>中的del()函数</code>​ <code>**=&gt;**</code> ​<strong>db.class.php</strong>​<code>文件中array2sql()+master_db-&gt;delete(函数)</code>​ <code>**=&gt;**</code> ​<strong>mysqli.class.php</strong>​<code>文件中的delete()函数</code>​ <code>**=&gt;**</code> ​<code>query()函数</code>​。分析认为是query()会导致报错注入。</p><p>‍</p>        <h6 id="分析构造payload">          <a href="#分析构造payload" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析构造payload" class="headerlink" title="分析构造payload"></a>分析构造payload</h6>      <p>query()函数，想要报错，只需要传入的<code>$sql</code>​语句可以报错即可</p><p><img src="/posts/e754e93d/image-20231224141948-lbn5eva.png" alt="image">​</p><p>分析delete()函数，参数<code>$where</code>​是可控的，追溯到<code>$where</code>​变量</p><p><img src="/posts/e754e93d/image-20231224142042-zz8ldwh.png" alt="image">​</p><p>db.class.php文件中delete()函数，<code>$where</code>​变量可控但是会进行array2sql()函数，现在分析array2sql()函数</p><p><img src="/posts/e754e93d/image-20231224142129-w1kdbu7.png" alt="image">​</p><p>注释写了是数组转化为sql格式，但是中间有一段str_replace()函数的简单过滤。先写出报错注入的语句，然后根据过滤进行修改</p><p><code>AND updatexml(rand(),concat(0x3a,database(),0x3a),rand()) --+</code>​</p><p><img src="/posts/e754e93d/image-20231224142222-pw0326f.png" alt="image">​</p><p>通过分析其过滤了空格和’替空，可以利用+号代替空格。其次<code>$sql</code>​语句的拼接是直接拼接传入的$val，所以不需要其他绕过了</p><p>所以payload：<code>AND+updatexml(rand(),concat(0x3a,database(),0x3a),rand())+--+</code>​</p><p>现在回到入口文件处，分析<code>$where</code>​的传入方式：判断传入的groupid参数是否是数组，这里发现不是的话，会进入else语句，其中的调用<code>db-&gt;delete()</code>​,是直接传入我们输入的参数。所以可以实现报错注入</p><p><img src="/posts/e754e93d/image-20231224143255-8g96vny.png" alt="image">​</p><p>最终Payload：<code>+AND+updatexml(rand(),concat(0x3a,database(),0x3a),rand())+--+</code>​</p><p><img src="/posts/e754e93d/image-20231224143510-9w8z0md.png" alt="image">​</p><p>‍</p>        <h4 id="导出excel">          <a href="#导出excel" class="heading-link"><i class="fas fa-link"></i></a><a href="#导出excel" class="headerlink" title="导出excel"></a>导出excel</h4>      <p>在coreframe&#x2F;app&#x2F;pay&#x2F;admin&#x2F;index.php文件中，入口代码30-43行：</p><p><img src="/posts/e754e93d/wps1-20231225143658-lt97i15.jpg">​</p><p>通过status参数传入<code>$where</code>​变量上<code>$status</code>​变量，该变量未经过详细的过滤，可以作为sql注入的入侵点。接着通过if条件判断，将<code>$status</code>​参数提交的值拼接在</p><p>在第88行，通过调用coreframe&#x2F;app&#x2F;core&#x2F;libs&#x2F;class&#x2F;db.class.php文件中的get_list()函数，传入<code>$where</code>​变量</p><p><img src="/posts/e754e93d/wps2-20231225143658-ozowkbz.jpg">​</p><p>因为传入的<code>$where</code>​为非数组变量，所以进过简单过滤直接传入到coreframe&#x2F;app&#x2F;core&#x2F;libs&#x2F;class&#x2F;mysqli.class.php文件中的get_list()函数</p><p><img src="/posts/e754e93d/wps3-20231225143658-2okxsc2.jpg">​</p><p>在coreframe&#x2F;app&#x2F;core&#x2F;libs&#x2F;class&#x2F;mysqli.class.php文件中的get_list()函数里，传入的<code>$where</code>​变量，直接拼接为新的<code>$where</code>​变量，并且拼接到<code>$sql</code>​语句中，利用自定义的query()函数执行sql查询</p><p><img src="/posts/e754e93d/wps4-20231225143658-f2xjypo.jpg">​</p><p>自定义的query()sql查询语句，当查询错误时，会触发halt()函数，在237行该函数中调用了mysqli_error(),导致了报错注入</p><p><img src="/posts/e754e93d/wps5-20231225143658-9qaj9zx.jpg">​</p><p><img src="/posts/e754e93d/wps6-20231225143658-lwvor5d.jpg">​</p><p>‍</p>        <h3 id="任意文件写入">          <a href="#任意文件写入" class="heading-link"><i class="fas fa-link"></i></a><a href="#任意文件写入" class="headerlink" title="任意文件写入"></a>任意文件写入</h3>      <p>file_put_contents()</p><p>fwrite()</p><p>这里主要用到的是敏感函数回溯。通过seay源代码分析，先找一些主要是可以接收变量的，然后找存在注释的。</p><p><img src="/posts/e754e93d/image-20231224151500-lc0t9wn.png" alt="image">​</p><p><img src="/posts/e754e93d/image-20231224150642-tdk2sr7.png" alt="image">​</p><p>这里找到一对，写入缓存和读取缓存内容，关键是读取缓存内容中使用了<code>include</code>​包含</p><p>追溯函数的调用，全局搜索函数，发现有一处函数调用了set_cache，同时参数可控，并且该函数中同时调用了get_cache()</p><p>​<img src="/posts/e754e93d/image-20231224155546-t15v4ga.png" alt="image">​​</p><p>直接根据路由分析出Payload：<code>https://www.testwuzhi.com/index.php?m=attachment&amp;f=index&amp;v=ueditor&amp;_su=wuzhicms&amp;submit=XXX&amp;setting=&lt;?php%20phpinfo();?&gt;</code>​</p><p>可以看到ueditor函数中，如果没有submit写入，就会调用get_cache函数，而这个函数式用来读取缓存内容的。<img src="/posts/e754e93d/image-20231221161236-34phrcw.png" alt="image">​</p><p>‍</p>        <h1 id="思考">          <a href="#思考" class="heading-link"><i class="fas fa-link"></i></a><a href="#思考" class="headerlink" title="思考"></a>思考</h1>      <blockquote><p>在sql注入处，分析出因为query()函数的定义，导致的报错注入，那么是不是涉及到调用query()函数的都存在报错注入?</p></blockquote><p>‍</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test Article</title>
      <link href="/posts/7c87bbf6/"/>
      <url>/posts/7c87bbf6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
